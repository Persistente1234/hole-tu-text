<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agujero de Amor: Letras Rosas y Corazones Flotantes | VIC PERSI</title>
    <style>
        /* --- ESTILOS GENERALES Y AGUJERO NEGRO --- */
        body {
            width: 100vw;
            height: 100vh;
            background: #000; /* Fondo oscuro para el contraste */
            overflow: hidden;
            margin: 0;
            padding: 0;
            cursor: pointer;
            font-family: Arial, sans-serif;
        }

        black-hole {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        black-hole canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- ESTILOS DEL CREADOR SOLICITADO --- */
        .creator-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateY(35vh); /* Posición más baja para no tapar el agujero */
            font-size: 8vw; /* Tamaño grande y responsivo */
            font-weight: bold;
            color: red; /* Letras rojas */
            text-shadow: 
                0 0 10px rgba(255, 105, 180, 0.7), /* Resplandor rosa/fosforescente */
                0 0 20px rgba(255, 105, 180, 0.7),
                0 0 30px rgba(255, 105, 180, 0.7),
                0 0 40px rgba(255, 0, 0, 0.5), /* Resplandor rojo adicional */
                0 0 50px rgba(255, 0, 0, 0.5);
            animation: pulsate 1.5s infinite alternate; /* Animación de resplandor pulsante */
            z-index: 10; /* Asegura que esté por encima del agujero negro */
            pointer-events: none; /* Ignorar eventos de clic en el texto */
        }
        
        @keyframes pulsate {
            0% {
                text-shadow: 
                    0 0 10px rgba(255, 105, 180, 0.7), 
                    0 0 20px rgba(255, 105, 180, 0.7),
                    0 0 30px rgba(255, 105, 180, 0.7),
                    0 0 40px rgba(255, 0, 0, 0.5), 
                    0 0 50px rgba(255, 0, 0, 0.5);
                opacity: 0.9;
            }
            100% {
                text-shadow: 
                    0 0 15px rgba(255, 105, 180, 1), 
                    0 0 25px rgba(255, 105, 180, 1),
                    0 0 35px rgba(255, 105, 180, 1),
                    0 0 45px rgba(255, 0, 0, 0.8), 
                    0 0 55px rgba(255, 0, 0, 0.8),
                    0 0 65px rgba(255, 0, 0, 0.8);
                opacity: 1;
            }
        }
    </style>
</head>
<body>

    <div class="creator-text">CREADOR VIC PERSI</div> 

    <black-hole class="js-black-hole">
        <canvas class="js-canvas"></canvas>
    </black-hole>

    <audio id="bg-music" loop>
        <source src="rap de amor.mp3" type="audio/mpeg">
        Tu navegador no soporta el elemento de audio.
    </audio>

    <script type="text/javascript">
        // Iniciar la reproducción de audio al primer clic en la página
        document.addEventListener('DOMContentLoaded', function() {
            const audio = document.getElementById('bg-music');
            audio.volume = 0.4;
            
            // Intenta reproducir al cargar (puede fallar por políticas del navegador)
            audio.play().catch(e => console.log("La reproducción automática no está permitida. Esperando interacción del usuario."));

            // Asegura la reproducción con el primer clic en el documento
            document.addEventListener('click', function() {
                audio.play().catch(e => console.log("Audio no pudo reproducirse"));
            }, { once: true });
        });
        
        // --- CÓDIGO JAVASCRIPT DE LA ANIMACIÓN ---

        const easingUtils = {
            easeLinear: p => p,
            easeInCubic: p => p * p * p,
            easeOutCubic: p => 1 - Math.pow(1 - p, 3),
            easeInOutCubic: p => p < 0.5 ? 4 * p * p * p : 1 - Math.pow(-2 * p + 2, 3) / 2,
            easeInExpo: p => p === 0 ? 0 : Math.pow(2, 10 * (p - 1)),
            easeOutExpo: p => p === 1 ? 1 : 1 - Math.pow(2, -10 * p),
            easeInOutExpo: p => p === 0 ? 0 : p === 1 ? 1 : p < 0.5 ? Math.pow(2, 20 * p - 10) / 2 : (2 - Math.pow(2, -20 * p + 10)) / 2,
            easeInSine: p => 1 - Math.cos((p * Math.PI) / 2),
            easeOutSine: p => Math.sin((p * Math.PI) / 2),
            easeInOutSine: p => -(Math.cos(Math.PI * p) - 1) / 2,
            easeInQuad: p => p * p,
            easeOutQuad: p => 1 - (1 - p) * (1 - p),
            easeInOutQuad: p => p < 0.5 ? 2 * p * p : 1 - Math.pow(-2 * p + 2, 2) / 2,
            easeInCirc: p => -(Math.sqrt(1 - p * p) - 1),
            easeOutCirc: p => Math.sqrt(1 - Math.pow(p - 1, 2)),
            easeInOutCirc: p => p < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * p, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * p + 2, 2)) + 1) / 2,
            easeInElastic: p => p === 0 ? 0 : p === 1 ? 1 : -Math.pow(2, 10 * p - 10) * Math.sin((p * 10 - 10.75) * ((2 * Math.PI) / 3)),
            easeOutElastic: p => p === 0 ? 0 : p === 1 ? 1 : Math.pow(2, -10 * p) * Math.sin((p * 10 - 0.75) * ((2 * Math.PI) / 3)) + 1,
            easeInOutElastic: p => p === 0 ? 0 : p === 1 ? 1 : p < 0.5 ? -(Math.pow(2, 20 * p - 10) * Math.sin((20 * p - 11.125) * ((2 * Math.PI) / 4.5))) / 2 : (Math.pow(2, -20 * p + 10) * Math.sin((20 * p - 11.125) * ((2 * Math.PI) / 4.5))) / 2 + 1,
            easeInBack: p => 2.70158 * p * p * p - 1.70158 * p * p,
            easeOutBack: p => 1 + 2.70158 * Math.pow(p - 1, 3) + 1.70158 * Math.pow(p - 1, 2),
            easeInOutBack: p => p < 0.5 ? (Math.pow(2 * p, 2) * ((2.59491 * 2 * p) - 1.59491)) / 2 : (Math.pow(2 * p - 2, 2) * ((2.59491 * (2 * p - 2)) + 1.59491) + 2) / 2
        };

        class BlackHole extends HTMLElement {
            connectedCallback() {
                this.canvas = this.querySelector(".js-canvas");
                this.ctx = this.canvas.getContext("2d");
                
                this.phrases = [
                    "EXPLORA EL COSMOS", "LA CIENCIA ES MAGIA", "BIENVENIDO VIAJERO",
                    "CREATIVIDAD INFINITA", "EL CÓDIGO FLUYE", "¡HOLA MUNDO!",
                    "VIAJE A LA SINGULARIDAD", "EL TIEMPO SE CURVA", "MÁS ALLÁ DEL HORIZONTE" 
                ];
                this.finalText = "";
                this.textFormed = false;
                this.textAlpha = 0;
                this.centerArrivalThreshold = 0.005;
                this.currentPhrase = null;
                this.formedPhraseChars = [];
                this.nextCharToFind = '';
                this.lastPhraseIndex = -1; 

                this.lovePhrases = [
                    "TE AMO", "ERES MI UNIVERSO", "JUNTOS POR SIEMPRE",
                    "MI CORAZÓN ES TUYO", "AMOR ETERNO", "MI DULCE AMOR",
                    "ERES PERFECTA", "CONTIGO TODO ES MEJOR", "MI ALMA GEMELA",
                    "MI TODO", "PARA SIEMPRE", "NUNCA TE VAYAS" 
                ];
                this.displayedLoveTexts = []; 
                this.activeHearts = []; 
                this.heartSpawnInterval = null; 

                this.startTime = Date.now(); 

                this.setSizes();
                this.bindEvents();
                this.setDiscs();
                this.setDots(); 
                this.startHeartSpawning(); 
                
                requestAnimationFrame(this.tick.bind(this));
            }

            bindEvents() {
                window.addEventListener("resize", this.onResize.bind(this));
                this.addEventListener("pointerdown", this.onPointerDown.bind(this));
            }

            onPointerDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const clientX = (e.clientX - rect.left) * scaleX / this.render.dpi;
                const clientY = (e.clientY - rect.top) * scaleY / this.render.dpi;

                // --- Lógica para clics en letras del agujero negro ---
                if (this.textFormed && !this.currentPhrase) {
                    this.resetAnimation();
                    return;
                } else if (!this.currentPhrase) { 
                    this.generatePhrase();
                    return;
                }

                // --- Lógica para clics en corazones ---
                for (let i = this.activeHearts.length - 1; i >= 0; i--) {
                    const heart = this.activeHearts[i];
                    // Solo si el corazón ya ha subido un poco para evitar clics accidentales en el centro
                    if (heart.y > this.render.hHeight + heart.size / 2) continue; 

                    const dist = Math.sqrt(Math.pow(heart.x - clientX, 2) + Math.pow(heart.y - clientY, 2));
                    if (dist < heart.size * 0.7) { 
                        this.spawnLoveText(heart.x, heart.y);
                        this.activeHearts.splice(i, 1); 
                        return; 
                    }
                }
            }

            resetAnimation() {
                this.finalText = "";
                this.textFormed = false;
                this.textAlpha = 0;
                this.currentPhrase = null;
                this.formedPhraseChars = [];
                this.nextCharToFind = '';
                this.targetDot = null;
                this.setDots(); 
            }

            generatePhrase() {
                let randomIndex;
                do {
                    randomIndex = Math.floor(Math.random() * this.phrases.length);
                } while (randomIndex === this.lastPhraseIndex); 
                
                this.lastPhraseIndex = randomIndex;
                this.currentPhrase = this.phrases[randomIndex];
                this.formedPhraseChars = [];
                this.textFormed = false;
                this.assignNextTargetDot();
            }

            assignNextTargetDot() {
                if (!this.currentPhrase || this.formedPhraseChars.length >= this.currentPhrase.length) {
                    this.targetDot = null;
                    return;
                }

                this.nextCharToFind = this.currentPhrase[this.formedPhraseChars.length];
                
                const availableDots = this.dots.filter(dot => !dot.reachedCenter && !dot.isTargetChar);
                if (availableDots.length > 0) {
                    const randomDotIndex = Math.floor(Math.random() * availableDots.length);
                    this.targetDot = availableDots[randomDotIndex];
                    this.targetDot.char = this.nextCharToFind;
                    this.targetDot.isTargetChar = true;
                } else {
                    this.targetDot = null;
                }
            }
            
            // --- Lógica para Corazones ---
            startHeartSpawning() {
                clearInterval(this.heartSpawnInterval); // Limpia cualquier intervalo previo
                this.heartSpawnInterval = setInterval(() => {
                    this.spawnHeart();
                }, 400 + Math.random() * 800); // Genera más frecuentemente y de forma más variable
            }

            spawnHeart() {
                const hue = 330 + Math.random() * 30; // Tonos rosas a rojos
                const saturation = 90 + Math.random() * 10;
                const lightness = 60 + Math.random() * 20; 
                
                const heart = {
                    x: this.render.hWidth + (Math.random() - 0.5) * this.render.width * 0.05, 
                    y: this.render.hHeight + Math.random() * 10, 
                    vx: (Math.random() - 0.5) * 0.4, // Menos dispersión horizontal
                    vy: -(1.5 + Math.random() * 1.5), // Velocidad hacia arriba: más rápida y variable
                    size: Math.max(15, 20 + Math.random() * 15), 
                    color: `hsl(${hue}, ${saturation}%, ${lightness}%)`,
                    alpha: 1,
                    fadeRate: 0.003 + Math.random() * 0.002 // Tasa de desvanecimiento más lenta para que suban más
                };
                this.activeHearts.push(heart);
            }

            spawnLoveText(x, y) {
                let randomIndex;
                // Evita repetir la última frase de amor, si es posible
                do {
                    randomIndex = Math.floor(Math.random() * this.lovePhrases.length);
                } while (randomIndex === this.lastPhraseIndex && this.lovePhrases.length > 1);
                this.lastPhraseIndex = randomIndex; 
                
                const phrase = this.lovePhrases[randomIndex];
                this.displayedLoveTexts.push({
                    phrase: phrase,
                    x: x,
                    y: y,
                    charProgress: 0, 
                    alpha: 1, 
                    startTime: Date.now(),
                    spawnDuration: phrase.length * 100 + 500, 
                    fadeStartTime: 0, 
                    fadeDuration: 3000 
                });
            }

            onResize() {
                this.setSizes();
                this.startHeartSpawning(); // Asegura que el intervalo se reinicie con las nuevas dimensiones
            }

            setSizes() {
                const rect = this.getBoundingClientRect();
                this.render = {
                    width: rect.width,
                    hWidth: rect.width * 0.5,
                    height: rect.height,
                    hHeight: rect.height * 0.5,
                    dpi: window.devicePixelRatio
                };
                this.canvas.width = this.render.width * this.render.dpi;
                this.canvas.height = this.render.height * this.render.dpi;
                this.setDiscs();
            }

            setDiscs() {
                this.discs = [];
                this.startDisc = {
                    x: this.render.width * 0.5,
                    y: this.render.height * 0, 
                    w: this.render.width * 1,
                    h: this.render.height * 1
                };
                const totalDiscs = 150;
                for (let i = 0; i < totalDiscs; i++) {
                    const p = i / totalDiscs;
                    const disc = this.tweenDisc({ p });
                    this.discs.push(disc);
                }
            }

            setDots() {
                this.dots = [];
                const totalDots = 5000;
                const alphabetAndSpace = "ABCDEFGHIJKLMNOPQRSTUVWXYZ ";
                for (let i = 0; i < totalDots; i++) {
                    const disc = this.discs[Math.floor(this.discs.length * Math.random())];
                    const randomChar = alphabetAndSpace.charAt(Math.floor(Math.random() * alphabetAndSpace.length));
                    
                    // --- MISMO RANGO DE COLORES ROSAS/ROJOS PARA LAS LETRAS ---
                    const hue = 330 + Math.random() * 30; // Tonos rosas a rojos
                    const saturation = 90 + Math.random() * 10;
                    const lightness = 60 + Math.random() * 20; 
                    
                    const dot = {
                        d: disc, a: 0,
                        c: `hsl(${hue}, ${saturation}%, ${lightness}%)`,
                        p: Math.random(), o: Math.random() * 0.5 + 0.5,
                        char: randomChar, reachedCenter: false, isTargetChar: false
                    };
                    this.dots.push(dot);
                }
            }

            tweenDisc(disc) {
                const { startDisc } = this;
                const scaleX = this.tweenValue(1, 0, disc.p, 'outCubic');
                const scaleY = this.tweenValue(1, 0, disc.p, 'outExpo');
                disc.sx = scaleX;
                disc.sy = scaleY;
                disc.w = startDisc.w * scaleX;
                disc.h = startDisc.h * scaleY;
                
                disc.x = startDisc.x;
                disc.y = this.render.hHeight + disc.p * (startDisc.h * 0.5); 
                return disc;
            }

            tweenValue(start, end, p, ease = false) {
                const delta = end - start;
                const easeFn = easingUtils[ease ? "ease" + ease.charAt(0).toUpperCase() + ease.slice(1) : "linear"];
                return start + delta * easeFn(p);
            }
            
            drawDiscs() {
                const { ctx } = this;
                ctx.strokeStyle = 'rgba(255, 0, 100, 0.2)'; 
                ctx.lineWidth = 1;
                this.discs.forEach((disc) => {
                    ctx.beginPath();
                    ctx.globalAlpha = disc.a * 0.5;
                    ctx.ellipse(disc.x, disc.y + disc.h, disc.w, disc.h, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.closePath();
                });
            }

            drawDots() {
                const { ctx } = this;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                this.dots.forEach((dot) => {
                    const { d, a, p, c, o, char } = dot;
                    if (dot.reachedCenter) return;
                    
                    const _p = d.sx * d.sy;
                    ctx.font = `${Math.max(8, 12 * (1 - _p) + 2)}px Arial`;
                    const newA = a + (Math.PI * 2 * p);
                    const x = d.x + Math.cos(newA) * d.w;
                    const y = this.render.hHeight + Math.sin(newA) * d.h; 
                    ctx.globalAlpha = d.a * o;

                    const closeness = 1 - dot.d.sy; 
                    
                    if (closeness > 0.8) {
                        // Cerca del centro: Transiciona a blanco brillante para las letras
                        ctx.fillStyle = `hsl(0, 0%, ${70 + 30 * ((closeness - 0.8) / 0.2)}%)`; // Blanco incandescente
                    } else if (closeness > 0.5) {
                        // Zona media: Mantiene el color base (rosa/rojo), pero aumenta la luminosidad
                        const baseHue = parseInt(dot.c.match(/hsl\((\d+)/)[1]);
                        const brightL = 70 + 30 * (closeness - 0.5) / 0.3; 
                        ctx.fillStyle = `hsl(${baseHue}, 100%, ${brightL}%)`;
                    } else {
                        // Lejos del centro: Usa el color inicial rosa/rojo del dot
                        ctx.fillStyle = c;
                    }
                    
                    ctx.fillText(char, x, y);
                });
            }

            drawFinalText() {
                if (!this.finalText) return;
                const { ctx, render } = this;
                
                const brightness = 0.75 + Math.sin(this.elapsedTime / 300) * 0.25;
                // El texto formado también será en tonos rosa/rojo brillante
                const colorValue = Math.floor(200 + 55 * brightness); // Rango de 200 a 255 para el componente
                
                ctx.save();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                ctx.fillStyle = `rgba(255, ${colorValue}, ${colorValue}, ${this.textAlpha})`; // Un rosa más intenso
                
                ctx.font = `bold ${render.height * 0.05}px Arial`;
                ctx.fillText(this.finalText, render.hWidth, render.hHeight);
                ctx.restore();
            }

            drawHeart(ctx, x, y, size, color) {
                ctx.save();
                ctx.beginPath();
                ctx.translate(x, y);
                ctx.scale(size / 20, size / 20); 
                
                ctx.moveTo(0, 0);
                ctx.bezierCurveTo(2.5, -10, 10, -10, 10, -2.5);
                ctx.bezierCurveTo(10, 5, 0, 10, 0, 10);
                ctx.bezierCurveTo(0, 10, -10, 5, -10, -2.5);
                ctx.bezierCurveTo(-10, -10, -2.5, -10, 0, 0);
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
                ctx.restore();
            }

            drawActiveHearts() {
                const { ctx } = this;
                this.activeHearts.forEach(heart => {
                    ctx.save();
                    ctx.globalAlpha = heart.alpha;
                    this.drawHeart(ctx, heart.x, heart.y, heart.size, heart.color);
                    ctx.restore();
                });
            }

            drawDisplayedLoveTexts() {
                const { ctx, render } = this;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                for (let i = this.displayedLoveTexts.length - 1; i >= 0; i--) {
                    const textObj = this.displayedLoveTexts[i];
                    const elapsed = Date.now() - textObj.startTime;

                    if (elapsed < textObj.spawnDuration) {
                        textObj.charProgress = Math.min(textObj.phrase.length, Math.floor(elapsed / 100));
                        textObj.alpha = 1; 
                    } else if (!textObj.fadeStartTime) {
                        textObj.fadeStartTime = Date.now();
                    }

                    if (textObj.fadeStartTime) {
                        const fadeElapsed = Date.now() - textObj.fadeStartTime;
                        textObj.alpha = 1 - Math.min(1, fadeElapsed / textObj.fadeDuration);
                    }

                    if (textObj.alpha <= 0) {
                        this.displayedLoveTexts.splice(i, 1);
                        continue;
                    }

                    const currentPhrasePart = textObj.phrase.substring(0, textObj.charProgress);
                    
                    ctx.save();
                    ctx.globalAlpha = textObj.alpha;
                    ctx.fillStyle = `rgba(255, 200, 220, ${textObj.alpha})`; 
                    ctx.font = `bold ${render.height * 0.04}px Arial`;
                    ctx.fillText(currentPhrasePart, textObj.x, textObj.y);
                    ctx.restore();
                }
            }


            moveDiscs() {
                this.discs.forEach((disc) => {
                    disc.p = (disc.p + 0.0003) % 1;
                    this.tweenDisc(disc);
                    const p = disc.sx * disc.sy;
                    let a = 1;
                    if (p < 0.01) {
                        a = Math.pow(Math.min(p / 0.01, 1), 3);
                    } else if (p > 0.2) {
                        a = 1 - Math.min((p - 0.2) / 0.8, 1);
                    }
                    disc.a = a;
                });
            }

            moveDots() {
                this.dots.forEach((dot) => {
                    if (dot.reachedCenter) return;
                    let v = this.tweenValue(0.0005, 0.005, 1 - dot.d.sx * dot.d.sy, 'inExpo');
                    
                    if (dot.isTargetChar) {
                        v *= 15; 
                    }

                    dot.p = (dot.p + v) % 1;

                    if (dot.isTargetChar && dot.d.sy < this.centerArrivalThreshold && !dot.reachedCenter) {
                        dot.reachedCenter = true;
                        dot.d.a = 0;
                        this.formedPhraseChars.push(dot.char);
                        this.finalText = this.formedPhraseChars.join('');
                        dot.isTargetChar = false;

                        if (this.finalText.length === this.currentPhrase.length) {
                            this.textFormed = true;
                            setTimeout(() => this.resetAnimation(), 5000); 
                        } else {
                            this.assignNextTargetDot();
                        }
                    }
                });
            }

            moveActiveHearts() {
                for (let i = this.activeHearts.length - 1; i >= 0; i--) {
                    const heart = this.activeHearts[i];
                    heart.x += heart.vx;
                    heart.y += heart.vy;
                    heart.alpha -= heart.fadeRate;

                    // Remover corazones cuando se desvanecen o salen de la pantalla
                    if (heart.alpha <= 0 || heart.y < -heart.size || heart.x < -heart.size || heart.x > this.render.width + heart.size) {
                        this.activeHearts.splice(i, 1);
                    }
                }
            }
            
            tick(time) {
                const { ctx } = this;
                this.elapsedTime = time - this.startTime; 
                
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                ctx.save();
                ctx.scale(this.render.dpi, this.render.dpi);
                
                this.moveDiscs();
                this.moveDots(); 
                this.moveActiveHearts(); 

                this.drawDiscs();
                this.drawDots(); 
                this.drawFinalText(); 

                this.drawActiveHearts(); 
                this.drawDisplayedLoveTexts(); 

                ctx.restore();

                if (this.textFormed && this.textAlpha < 1) {
                    this.textAlpha = Math.min(1, this.textAlpha + 0.01);
                } else if (!this.textFormed && this.currentPhrase && this.textAlpha > 0) {
                    this.textAlpha = Math.max(0, this.textAlpha - 0.02);
                } else if (!this.currentPhrase && this.textAlpha > 0) {
                     this.textAlpha = Math.max(0, this.textAlpha - 0.02);
                } else if (!this.currentPhrase && this.textAlpha === 0 && this.finalText.length > 0) {
                     this.finalText = "";
                }

                requestAnimationFrame(this.tick.bind(this));
            }
        }
        customElements.define("black-hole", BlackHole);
    </script>
</body>
</html>